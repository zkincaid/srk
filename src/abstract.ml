open Syntax
open Linear
open BatPervasives

include Log.Make(struct let name = "srk.abstract" end)

module V = Linear.QQVector
module CS = CoordinateSystem

let opt_abstract_limit = ref (-1)

(* Counter-example based extraction of the subspace of the function
   space generated by [terms] that vanishes on the models of phi.
   This works by repeatedly posing new (linearly independent)
   functions; each function either vanishes on the formula (and gets
   added to the vanishing space) or there is a counter-model on which
   the function does not vanish.  Counter-models are collectied in a
   system of linear equations where the variables are the coefficients
   of candidate functions. *)
let vanishing_space srk phi terms =
  let solver = Smt.mk_solver srk in
  let zero = mk_zero srk in
  Smt.Solver.add solver [phi];
  let next_row =
    let n = ref (-1) in
    fun () -> incr n; (!n)
  in
  let rec go vanishing_fns mat dim =
    if dim < 0 then
      vanishing_fns
    else
      let row_num = next_row () in
      (* Find a candidate function which vanishes on all previously
         sampled points *)
      let mat' = QQMatrix.add_row row_num (QQVector.of_term QQ.one dim) mat in
      match Linear.solve mat' (QQVector.of_term QQ.one row_num) with
      | None -> go vanishing_fns mat (dim - 1)
      | Some candidate ->
         Smt.Solver.push solver;
         let candidate_term =
           Linear.term_of_vec srk (fun i -> terms.(i)) candidate
         in
         Smt.Solver.add solver [
             mk_not srk (mk_eq srk candidate_term zero)
           ];
         match Smt.Solver.get_model solver with
         | `Unknown -> (* give up; return the functions we have so far *)
            logf ~level:`warn
              "vanishing_space timed out (%d functions)"
              (List.length vanishing_fns);
            vanishing_fns
         | `Unsat -> (* candidate vanishes on phi *)
            Smt.Solver.pop solver 1;
            go (candidate::vanishing_fns) mat' (dim - 1)
         | `Sat point -> (* candidate is non-zero at point *)
            Smt.Solver.pop solver 1;
            let point_row =
              BatArray.fold_lefti (fun row i t ->
                  QQVector.add_term (Interpretation.evaluate_term point t) i row)
                QQVector.zero
                terms
            in
            let mat' = QQMatrix.add_row row_num point_row mat in
            (* We never choose the same candidate function again,
               because the only solutions to the system of equations
               mat' x = 0 are functions that vanish on all samples *)
            go vanishing_fns mat' dim
  in
  go [] QQMatrix.zero (Array.length terms - 1)

let affine_hull srk phi constants =
  let basis = BatArray.of_list (mk_one srk :: (List.map (mk_const srk) constants)) in
  vanishing_space srk phi basis
  |> List.map (Linear.term_of_vec srk (fun i -> basis.(i)))

let boxify srk phi terms =
  let mk_box t ivl =
    let lower =
      match Interval.lower ivl with
      | Some lo -> [mk_leq srk (mk_real srk lo) t]
      | None -> []
    in
    let upper =
      match Interval.upper ivl with
      | Some hi -> [mk_leq srk t (mk_real srk hi)]
      | None -> []
    in
    lower@upper
  in
  match SrkZ3.optimize_box srk phi terms with
  | `Sat intervals ->
    mk_and srk (List.concat (List.map2 mk_box terms intervals))
  | `Unsat -> mk_false srk
  | `Unknown -> assert false

let abstract ?exists:(p=fun _ -> true) srk man phi =
  let solver = Smt.mk_solver srk in
  let phi_symbols = symbols phi in
  let symbol_list = Symbol.Set.elements phi_symbols in
  let env_proj = SrkApron.Env.of_set srk (Symbol.Set.filter p phi_symbols) in
  let cs = CoordinateSystem.mk_empty srk in

  let disjuncts = ref 0 in
  let rec go prop =
    Smt.Solver.push solver;
    Smt.Solver.add solver [mk_not srk (SrkApron.formula_of_property prop)];
    let result =
      Log.time "lazy_dnf/sat" (Smt.Solver.get_concrete_model solver) symbol_list
    in
    match result with
    | `Unsat ->
      Smt.Solver.pop solver 1;
      prop
    | `Unknown ->
      begin
        logf ~level:`warn "abstraction timed out (%d disjuncts); returning top"
          (!disjuncts);
        Smt.Solver.pop solver 1;
        SrkApron.top man env_proj
      end
    | `Sat interp -> begin
        Smt.Solver.pop solver 1;
        incr disjuncts;
        logf "[%d] abstract lazy_dnf" (!disjuncts);
        if (!disjuncts) = (!opt_abstract_limit) then begin
          logf ~level:`warn "Met symbolic abstraction limit; returning top";
          SrkApron.top man env_proj
        end else begin
          let disjunct =
            match Interpretation.select_implicant interp phi with
            | Some d -> Polyhedron.of_implicant ~admit:true cs d
            | None -> assert false
          in

          let valuation =
            let table : QQ.t array =
              Array.init (CS.dim cs) (fun i ->
                  Interpretation.evaluate_term
                    interp
                    (CS.term_of_coordinate cs i))
            in
            fun i -> table.(i)
          in
          let projected_coordinates =
            BatEnum.filter (fun i ->
                match CS.destruct_coordinate cs i with
                | `App (sym, _) -> not (p sym)
                | _ -> true)
              (0 -- (CS.dim cs - 1))
            |> BatList.of_enum
          in
          let projected_disjunct =
            Polyhedron.local_project valuation projected_coordinates disjunct
            |> Polyhedron.to_apron cs env_proj man
          in
          go (SrkApron.join prop projected_disjunct)
        end
      end
  in
  Smt.Solver.add solver [phi];
  Log.time "Abstraction" go (SrkApron.bottom man env_proj)

module Sign = struct

  type sign = Zero | NonNeg | Neg | NonPos | Pos  | Top

  module M = Expr.Map
  type 'a t =
    | Env of ('a, typ_arith, sign) M.t
    | Bottom

  let formula_of srk signs =
    let zero = mk_real srk QQ.zero in
    match signs with
    | Bottom -> mk_false srk
    | Env map ->
      M.fold (fun term sign xs ->
          let term_sign =
            match sign with
            | Pos -> mk_lt srk zero term
            | Neg -> mk_lt srk term zero
            | Zero -> mk_eq srk term zero
            | NonNeg -> mk_leq srk zero term
            | NonPos -> mk_leq srk term zero
            | Top -> mk_true srk
          in
          term_sign::xs)
        map
        []
      |> mk_and srk

  let join x y =
    let join_sign x y =
      match x, y with
      | Zero, Zero -> Zero

      | Zero, NonNeg | NonNeg, Zero
      | Zero, Pos | Pos, Zero
      | Pos, NonNeg | NonNeg, Pos
      | NonNeg, NonNeg ->
        NonNeg

      | Pos, Pos -> Pos

      | Zero, NonPos | NonPos, Zero
      | Zero, Neg | Neg, Zero
      | Neg, NonPos | NonPos, Neg
      | NonPos, NonPos ->
        NonPos

      | Neg, Neg -> Neg

      | Neg, Pos | Pos, Neg
      | NonNeg, NonPos | NonPos, NonNeg -> Top
      | _, Top | Top, _ -> Top
      | Neg, NonNeg | NonNeg, Neg
      | Pos, NonPos | NonPos, Pos -> Top
    in
    match x, y with
    | Env x, Env y ->
      Env (M.merge (fun _ x y -> match x, y with
          | Some x, Some y -> Some (join_sign x y)
          | _, _ -> Some Top) x y)
    | Bottom, r | r, Bottom -> r

  let equal x y = match x, y with
    | Env x, Env y -> M.equal (=) x y
    | Bottom, Bottom -> true
    | _, _ -> false

  let of_model m terms =
    let rational_sign x =
      match QQ.compare x QQ.zero with
      | 0 -> Zero
      | c when c < 0 -> Neg
      | _ -> Pos
    in
    let env =
      List.fold_left (fun env term ->
          M.add term (rational_sign (Interpretation.evaluate_term m term)) env)
        M.empty
        terms
    in
    Env env

  let top = Env M.empty

  let bottom = Bottom

  let exists p signs = match signs with
    | Bottom -> Bottom
    | Env m ->
       Env (M.filter (fun term _ -> Symbol.Set.for_all p (symbols term)) m)

  let abstract srk phi terms =
    let solver = Smt.mk_solver srk in
    Smt.Solver.add solver [phi];
    let rec fix prop =
      Smt.Solver.add solver [mk_not srk (formula_of srk prop)];
      match Smt.Solver.get_model solver with
      | `Sat m ->
        fix (join (of_model m terms) prop)
      | `Unsat -> prop
      | `Unknown -> top
    in
    fix bottom
end

module MakeAbstractRSY (C : sig
    type t
    val context : t context
  end) = struct

  module type Domain = sig
    type t
    val top : t
    val bottom : t
    val exists : (symbol -> bool) -> t -> t
    val join : t -> t -> t
    val equal : t -> t -> bool
    val of_model : C.t Interpretation.interpretation -> symbol list -> t
    val formula_of : t -> C.t formula
  end

  module Sign = struct
    type t = C.t Sign.t
    let top = Sign.top
    let bottom = Sign.bottom
    let exists = Sign.exists
    let join = Sign.join
    let equal = Sign.equal
    let of_model interp symbols =
      Sign.of_model interp (List.map (mk_const C.context) symbols)
    let formula_of = Sign.formula_of C.context
  end

  module AffineRelation = struct
    type t = (C.t, Polka.equalities Polka.t) SrkApron.property

    let man = Polka.manager_alloc_equalities ()

    let top = SrkApron.top man (SrkApron.Env.of_list C.context [])
    let bottom = SrkApron.bottom man (SrkApron.Env.empty C.context)

    let of_model m symbols =
      let env = SrkApron.Env.of_list C.context symbols in
      List.map (fun sym ->
          Linear.QQVector.add_term
            (QQ.of_int (-1))
            (Linear.dim_of_sym sym)
            (Linear.const_linterm (Interpretation.real m sym))
          |> SrkApron.lexpr_of_vec env
          |> SrkApron.lcons_eqz
        ) symbols
      |> SrkApron.meet_lcons (SrkApron.top man env)

    let exists p prop = SrkApron.exists man p prop
    let join = SrkApron.join
    let equal = SrkApron.equal
    let formula_of = SrkApron.formula_of_property
  end

  module PredicateAbs (U : sig val universe : C.t formula list end) = struct
    module PS = struct
      include BatSet.Make(struct
          type t = C.t formula
          let compare = Formula.compare
        end)
    end

    type t = PS.t

    let universe = PS.of_list U.universe

    let exists p abs_state =
      PS.filter (fun predicate ->
          Symbol.Set.for_all p (symbols predicate))
        abs_state
    let top = PS.empty
    let bottom = universe
    let join = PS.inter
    let equal = PS.equal
    let of_model m _ = PS.filter (Interpretation.evaluate_formula m) universe
    let formula_of abs_state = mk_and C.context (PS.elements abs_state)
  end

  module Product (A : Domain) (B : Domain) = struct
    type t = A.t * B.t
    let top = (A.top, B.top)
    let bottom = (A.bottom, B.bottom)
    let exists p (v1, v2) = (A.exists p v1, B.exists p v2)
    let join (v1, v2) (v1', v2') = (A.join v1 v1', B.join v2 v2')
    let equal (v1, v2) (v1', v2') = A.equal v1 v1' && B.equal v2 v2'
    let of_model  m symbols = (A.of_model m symbols, B.of_model m symbols)
    let formula_of  (v1, v2) = mk_and C.context [A.formula_of v1; B.formula_of v2]
  end

  let abstract (type a)
      ?exists:(p=fun _ -> true)
      (module D : Domain with type t = a)
      phi =
    let phi_symbols = Symbol.Set.filter p (symbols phi) |> Symbol.Set.elements in
    let solver = Smt.mk_solver C.context in
    Smt.Solver.add solver [phi];
    let rec fix prop =
      Smt.Solver.add solver [mk_not C.context (D.formula_of prop)];
      match Smt.Solver.get_model solver with
      | `Sat m ->
         fix (D.join (D.of_model m phi_symbols) prop)
      | `Unsat -> prop
      | `Unknown ->
         logf ~level:`warn "Unknown result in MakeAbstractRSY.abstract";
         D.top
    in
    fix D.bottom

end
